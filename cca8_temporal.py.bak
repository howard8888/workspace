# -*- coding: utf-8 -*-


from __future__ import annotations
from dataclasses import dataclass, field
import random, math
from typing import List


# in temporal_context.py
__version__ = "0.1.0"

@dataclass
class TemporalContext:
    """128-D unit-norm temporal context with drift and boundary jumps.
    No NumPy dependency; uses stdlib only.
    """
    dim: int = 128
    sigma: float = 0.02   # per-tick drift scale
    jump: float = 0.25    # event-boundary jump scale
    _v: List[float] = field(default_factory=list)

    def __post_init__(self) -> None:
        if not self._v:
            vals = [random.gauss(0.0, 1.0) for _ in range(self.dim)]
            self._v = self._normalize(vals)

    def vector(self) -> list[float]:
        """Return a copy of the current context vector."""
        return list(self._v)

    def step(self) -> list[float]:
        vals = [a + random.gauss(0.0, self.sigma) for a in self._v]
        self._v = self._normalize(vals)
        return self.vector()

    def boundary(self) -> list[float]:
        vals = [a + random.gauss(0.0, self.jump) for a in self._v]
        self._v = self._normalize(vals)
        return self.vector()

    @staticmethod
    def _normalize(vals: list[float]) -> list[float]:
        s = math.sqrt(sum(a * a for a in vals)) or 1.0
        return [a / s for a in vals]
